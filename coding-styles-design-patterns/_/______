






// TODO: Architectural Patterns


// Monoliths / Microservices

// Monoliths (C):

// #include <stdio.h>

// Monolith example where all functionalities are combined in a single application

void processOrder() {
    printf("Processing order...\n");
}

void handleUser() {
    printf("Handling user...\n");
}

void test() {
    processOrder();
    handleUser();
}

// Monoliths (C++):

// #include <iostream>

// Monolith example where all functionalities are combined in a single application

void processOrder() {
    std::cout << "Processing order..." << std::endl;
}

void handleUser() {
    std::cout << "Handling user..." << std::endl;
}

void test() {
    processOrder();
    handleUser();


}

// Microservices (C):

// #include <stdio.h>
// #include <stdlib.h>
// #include <unistd.h>

// Microservice 1: Order Service
void orderService() {
    printf("Order service running...\n");
    sleep(1);
}

// Microservice 2: User Service
void userService() {
    printf("User service running...\n");
    sleep(1);
}

void test() {
    if (fork() == 0) {
        orderService();
        exit(0);
    }
    if (fork() == 0) {
        userService();
        exit(0);
    }
    sleep(2); // Allow services to run
}

// Microservices (C++):

// #include <iostream>
// #include <thread>

// Microservice 1: Order Service
void orderService() {
    std::cout << "Order service running..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
}

// Microservice 2: User Service
void userService() {
    std::cout << "User service running..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
}

void test() {
    std::thread orderThread(orderService);
    std::thread userThread(userService);

    orderThread.join();
    userThread.join();

}


// Model-View-Controller (MVC)

// MVC (C):

// #include <stdio.h>

// Model
typedef struct {
    int data;
} Model;

void setData(Model* model, int data) {
    model->data = data;
}

// View
void displayData(int data) {
    printf("Data: %d\n", data);
}

// Controller
void updateView(Model* model) {
    displayData(model->data);
}

void test() {
    Model model;
    setData(&model, 42);
    updateView(&model);
}

// MVC (C++):

// #include <iostream>

// Model
class Model {
    int data;
public:
    void setData(int data) {
        this->data = data;
    }
    int getData() const {
        return data;
    }
};

// View
void displayData(int data) {
    std::cout << "Data: " << data << std::endl;
}

// Controller
void updateView(const Model& model) {
    displayData(model.getData());
}

void test() {
    Model model;
    model.setData(42);
    updateView(model);
}


// Model-View-ViewModel (MVVM)

// MVVM (C):

// #include <stdio.h>

// Model
typedef struct {
    int data;
} Model;

void setData(Model* model, int data) {
    model->data = data;
}

// ViewModel
typedef struct {
    Model* model;
} ViewModel;

int getData(ViewModel* vm) {
    return vm->model->data;
}

// View
void displayData(int data) {
    printf("Data: %d\n", data);
}

void test() {
    Model model;
    setData(&model, 42);

    ViewModel viewModel = { &model };
    int data = getData(&viewModel);

    displayData(data);
}

// MVVM (C++):

// #include <iostream>

// Model
class Model {
    int data;
public:
    void setData(int data) {
        this->data = data;
    }
    int getData() const {
        return data;
    }
};

// ViewModel
class ViewModel {
    const Model& model;
public:
    ViewModel(const Model& model) : model(model) {}
    int getData() const {
        return model.getData();
    }
};

// View
void displayData(int data) {
    std::cout << "Data: " << data << std::endl;
}

void test() {
    Model model;
    model.setData(42);

    ViewModel viewModel(model);
    int data = viewModel.getData();

    displayData(data);
}


// Model-View-Controller-Service (MVCS)

// MVCS (C):

// #include <stdio.h>

// Model
typedef struct {
    int data;
} Model;

void setData(Model* model, int data) {
    model->data = data;
}

// View
void displayData(int data) {
    printf("Data: %d\n", data);
}

// Controller
typedef struct {
    Model* model;
    void (*view)(int);
} Controller;

void updateView(Controller* controller) {
    controller->view(controller->model->data);
}

void test() {
    Model model;
    setData(&model, 42);

    Controller controller = { &model, displayData };
    updateView(&controller);
}

// MVCS (C++):

// #include <iostream>

// Model
class Model {
    int data;
public:
    void setData(int data) {
        this->data = data;
    }
    int getData() const {
        return data;
    }
};

// View
void displayData(int data) {
    std::cout << "Data: " << data << std::endl;
}

// Controller
class Controller {
    const Model& model;
    void (*view)(int);
public:
    Controller(const Model& model, void (*view)(int)) : model(model), view(view) {}
    void updateView() const {
        view(model.getData());
    }
};

void test() {
    Model model;
    model.setData(42);

    Controller controller(model, displayData);
    controller.updateView();
}


// N-Tier Architecture (2-tier, 3-tier, N-tier)

// 2-Tier (C):

// #include <stdio.h>

// Data Access Layer
void fetchData() {
    printf("Fetching data...\n");
}

// Business Logic Layer
void processData() {
    fetchData();
    printf("Processing data...\n");
}

void test() {
    processData();
}

// 2-Tier (C++):

// #include <iostream>

// Data Access Layer
void fetchData() {
    std::cout << "Fetching data..." << std::endl;
}

// Business Logic Layer
void processData() {
    fetchData();
    std::cout << "Processing data..." << std::endl;
}

void test() {
    processData();


}

// 3-Tier (C):

// #include <stdio.h>

// Data Access Layer
void fetchData() {
    printf("Fetching data...\n");
}

// Business Logic Layer
void processData() {
    fetchData();
    printf("Processing data...\n");
}

// Presentation Layer
void displayData() {
    processData();
    printf("Displaying data...\n");
}

void test() {
    displayData();
}

// 3-Tier (C++):

// #include <iostream>

// Data Access Layer
void fetchData() {
    std::cout << "Fetching data..." << std::endl;
}

// Business Logic Layer
void processData() {
    fetchData();
    std::cout << "Processing data..." << std::endl;
}

// Presentation Layer
void displayData() {
    processData();
    std::cout << "Displaying data..." << std::endl;
}

void test() {
    displayData();


}

// N-Tier (C):

// #include <stdio.h>

// Data Access Layer
void fetchData() {
    printf("Fetching data...\n");
}

// Business Logic Layer
void processData() {
    fetchData();
    printf("Processing data...\n");
}

// Presentation Layer
void displayData() {
    processData();
    printf("Displaying data...\n");
}

// Additional layers can be added as needed

void test() {
    displayData();
}

// N-Tier (C++):

// #include <iostream>

// Data Access Layer
void fetchData() {
    std::cout << "Fetching data..." << std::endl;
}

// Business Logic Layer
void processData() {
    fetchData();
    std::cout << "Processing data..." << std::endl;
}

// Presentation Layer
void displayData() {
    processData();
    std::cout << "Displaying data..." << std::endl;
}

// Additional layers can be added as needed

void test() {
    displayData();
}


// Traditional-Layered Architecture

// Traditional-Layered-Architecture (C):

// #include <stdio.h>

// Presentation Layer
void presentData() {
    printf("Presenting data...\n");
}

// Business Logic Layer
void processBusinessLogic() {
    printf("Processing business logic...\n");
}

// Data Access Layer
void accessData() {
    printf("Accessing data...\n");
}

void test() {
    presentData();
    processBusinessLogic();
    accessData();
}

// Traditional-Layered-Architecture (C++):

// #include <iostream>

// Presentation Layer
void presentData() {
    std::cout << "Presenting data..." << std::endl;
}

// Business Logic Layer
void processBusinessLogic() {
    std::cout << "Processing business logic..." << std::endl;
}

// Data Access Layer
void accessData() {
    std::cout << "Accessing data..." << std::endl;
}

void test() {
    presentData();
    processBusinessLogic();
    accessData();
}


// Service-Oriented Architecture (SOA)

// SOA (C):

// #include <stdio.h>

// Service 1
void service1() {
    printf("Service 1 processing...\n");
}

// Service 2
void service2() {
    printf("Service 2 processing...\n");
}

void test() {
    service1();
    service2();
}

// SOA (C++):

// #include <iostream>

// Service 1
void service1() {
    std::cout << "Service 1 processing..." << std::endl;
}

// Service 2
void service2() {
    std::cout << "Service 2 processing..." << std::endl;
}

void test() {
    service1();
    service2();
}


// Domain-Driven Architecture

// Domain-Driven Architecture (C):

// #include <stdio.h>

// Domain Model
typedef struct {
    int value;
} DomainModel;

void processDomain(DomainModel* model) {
    printf("Processing domain value: %d\n", model->value);
}

void test() {
    DomainModel model = { 42 };
    processDomain(&model);
}

// Domain-Driven Architecture (C++):

// #include <iostream>

// Domain Model
class DomainModel {
    int value;
public:
    DomainModel(int v) : value(v) {}
    int getValue() const {
        return value;
    }
};

// Service
void processDomain(const DomainModel& model) {
    std::cout << "Processing domain value: " << model.getValue() << std::endl;
}

void test() {
    DomainModel model(42);
    processDomain(model);
}


// Event-Driven Architecture

// Event-Driven Architecture (C):

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

// Event System
typedef struct {
    void (*callback)(const char*);
} Event;

void emitEvent(Event* event, const char* data) {
    event->callback(data);
}

// Event Handlers
void onEvent(const char* data) {
    printf("Event received with data: %s\n", data);
}

void test() {
    Event event;
    event.callback = onEvent;
    emitEvent(&event, "Hello, World!");
}

// Event-Driven Architecture (C++):

// #include <iostream>
// #include <functional>

// Event System
class Event {
    std::function<void(const std::string&)> callback;
public:
    void setCallback(const std::function<void(const std::string&)>& cb) {
        callback = cb;
    }
    void emit(const std::string& data) {
        if (callback) {
            callback(data);
        }
    }
};

// Event Handlers
void onEvent(const std::string& data) {
    std::cout << "Event received with data: " << data << std::endl;
}

void test() {
    Event event;
    event.setCallback(onEvent);
    event.emit("Hello, World!");
}


// Space-Based Architecture

// Space-Based Architecture (C):

// #include <stdio.h>

// Space-based architecture example with simplified approach

// Space
void processInSpace() {
    printf("Processing in space...\n");
}

void test() {
    processInSpace();
}

// Space-Based Architecture (C++):

// #include <iostream>

// Space-based architecture example with simplified approach

// Space
void processInSpace() {
    std::cout << "Processing in space..." << std::endl;
}

void test() {
    processInSpace();
}


// Master-Slave Architecture

// Master-Slave (C):

// #include <stdio.h>

// Master process
void masterProcess() {
    printf("Master process executing...\n");
}

// Slave process
void slaveProcess() {
    printf("Slave process executing...\n");
}

void test() {
    masterProcess();
    slaveProcess();
}

// Master-Slave (C++):

// #include <iostream>

// Master process
void masterProcess() {
    std::cout << "Master process executing..." << std::endl;
}

// Slave process
void slaveProcess() {
    std::cout << "Slave process executing..." << std::endl;
}

void test() {
    masterProcess();
    slaveProcess();
}


// Self-Contained Services

// Self-Contained Services (C):

// #include <stdio.h>

// Service 1
void service1() {
    printf("Service 1 is self-contained\n");
}

// Service 2
void service2() {
    printf("Service 2 is self-contained\n");
}

void test() {
    service1();
    service2();
}

// Self-Contained Services (C++):

// #include <iostream>

// Service 1
void service1() {
    std::cout << "Service 1 is self-contained" << std::endl;
}

// Service 2
void service2() {
    std::cout << "Service 2 is self-contained" << std::endl;
}

void test() {
    service1();
    service2();
}


// Pipeline

// Pipeline (C):

// #include <stdio.h>

// Stage 1
void stage1(const char* input, char* output) {
    sprintf(output, "Stage 1 processed: %s", input);
}

// Stage 2
void stage2(const char* input, char* output) {
    sprintf(output, "Stage 2 processed: %s", input);
}

// Pipeline
void pipeline(const char* input) {
    char intermediate[100];
    char final[100];

    stage1(input, intermediate);
    stage2(intermediate, final);

    printf("Pipeline result: %s\n", final);
}

void test() {
    pipeline("data");
}

// Pipeline (C++):

// #include <iostream>
// #include <string>

// Stage 1
void stage1(const std::string& input, std::string& output) {
    output = "Stage 1 processed: " + input;
}

// Stage 2
void stage2(const std::string& input, std::string& output) {
    output = "Stage 2 processed: " + input;
}

// Pipeline
void pipeline(const std::string& input) {
    std::string intermediate;
    std::string final;

    stage1(input, intermediate);
    stage2(intermediate, final);

    std::cout << "Pipeline result: " << final << std::endl;
}

void test() {
    pipeline("data");
}


// Microkernel

// Microkernel (C):

// #include <stdio.h>

// Core System
void coreSystem() {
    printf("Core system running...\n");
}

// Plugin 1
void plugin1() {
    printf("Plugin 1 running...\n");
}

// Plugin 2
void plugin2() {
    printf("Plugin 2 running...\n");
}

void test() {
    coreSystem();
    plugin1();
    plugin2();
}

// Microkernel (C++):

// #include <iostream>

// Core System
void coreSystem() {
    std::cout << "Core system running..." << std::endl;
}

// Plugin 1
void plugin1() {
    std::cout << "Plugin 1 running..." << std::endl;
}

// Plugin 2
void plugin2() {
    std::cout << "Plugin 2 running..." << std::endl;
}

void test() {
    coreSystem();
    plugin1();
    plugin2();
}


// Hexagonal (Ports and Adapters)

// Hexagonal (Ports and Adapters) (C):

// #include <stdio.h>

// Application Core
void processData() {
    printf("Processing data in the core...\n");
}

// Adapter
void adapter() {
    printf("Adapter handling...\n");
    processData();
}

void test() {
    adapter();
}

// Hexagonal (Ports and Adapters) (C++):

// #include <iostream>

// Application Core
void processData() {
    std::cout << "Processing data in the core..." << std::endl;
}

// Adapter
void adapter() {
    std::cout << "Adapter handling..." << std::endl;
    processData();
}

void test() {
    adapter();
}


// 12-Factor Architecture

// 12-Factor Architecture (C):

// #include <stdio.h>

// Example is conceptual as the 12-Factor principles are for modern cloud applications and not directly translatable to C.

void printConfig() {
    printf("Configuration management example.\n");
}

void test() {
    printConfig();
}

// 12-Factor Architecture (C++):

// #include <iostream>

// Example is conceptual as the 12-Factor principles are for modern cloud applications and not directly translatable to C++.

void printConfig() {
    std::cout << "Configuration management example." << std::endl;
}

void test() {
    printConfig();
}


// 1-4 Party Payments

// 1-4 Party Payments (C):

// #include <stdio.h>

// Payment Processing for 1-4 Party Payments

void processPayment() {
    printf("Processing payment through 1-4 party system...\n");
}

void test() {
    processPayment();
}

// 1-4 Party Payments (C++):

// #include <iostream>

// Payment Processing for 1-4 Party Payments

void processPayment() {
    std::cout << "Processing payment through 1-4 party system..." << std::endl;
}

void test() {
    processPayment();
}



// TODO: Additional Architecture Patterns


// Event Sourcing

// Event Sourcing (C):

// #include <stdio.h>

// Event Store
void storeEvent(const char* event) {
    printf("Storing event: %s\n", event);
}

// Example event sourcing
void test() {
    storeEvent("User created");
    storeEvent("Order placed");
}

// Event Sourcing (C++):

// #include <iostream>
// #include <string>

// Event Store
void storeEvent(const std::string& event) {
    std::cout << "Storing event: " << event << std::endl;
}

// Example event sourcing
void test() {
    storeEvent("User created");
    storeEvent("Order placed");
}


// CQRS (Command Query Responsibility Segregation)

// CQRS (C):

// #include <stdio.h>

// Command Handler
void handleCommand(const char* command) {
    printf("Handling command: %s\n", command);
}

// Query Handler
void handleQuery(const char* query) {
    printf("Handling query: %s\n", query);
}

void test() {
    handleCommand("Create order");
    handleQuery("Get order details");
}

// CQRS (C++):

// #include <iostream>
// #include <string>

// Command Handler
void handleCommand(const std::string& command) {
    std::cout << "Handling command: " << command << std::endl;
}

// Query Handler
void handleQuery(const std::string& query) {
    std::cout << "Handling query: " << query << std::endl;
}

void test() {
    handleCommand("Create order");
    handleQuery("Get order details");
}


// Command Query Responsibility Segregation (CQRS)

// CQRS (C):

// #include <stdio.h>

// Command Handler
void handleCommand(const char* command) {
    printf("Handling command: %s\n", command);
}

// Query Handler
void handleQuery(const char* query) {
    printf("Handling query: %s\n", query);
}

void test() {
    handleCommand("Create order");
    handleQuery("Get order details");
}

// CQRS (C++):

// #include <iostream>
// #include <string>

// Command Handler
void handleCommand(const std::string& command) {
    std::cout << "Handling command: " << command << std::endl;
}

// Query Handler
void handleQuery(const std::string& query) {
    std::cout << "Handling query: " << query << std::endl;
}

void test() {
    handleCommand("Create order");
    handleQuery("Get order details");
}


// Serverless Architecture

// Serverless Architecture (C):

// #include <stdio.h>

// Serverless function example
void lambdaFunction() {
    printf("Running serverless function...\n");
}

void test() {
    lambdaFunction();
}

// Serverless Architecture (C++):

// #include <iostream>

// Serverless function example
void lambdaFunction() {
    std::cout << "Running serverless function..." << std::endl;
}

void test() {
    lambdaFunction();
}
