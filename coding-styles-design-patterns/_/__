

// OOP

// #include <stdio.h>

typedef struct {
    int x;
    int y;
} Point;

void print_point(Point *p) {
    printf("Point(%d, %d)\n", p->x, p->y);
}

void test() {
    Point p = {10, 20};
    print_point(&p);
}

// #include <iostream>

class Point {
public:
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
    void print() {
        std::cout << "Point(" << x << ", " << y << ")" << std::endl;
    }
};

void test() {
    Point p(10, 20);
    p.print();
}

// Declarative

// #include <stdio.h>

void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

void test() {
    int arr[] = {1, 2, 3, 4, 5};
    print_array(arr, 5);
}

// #include <iostream>
// #include <vector>

void print_vector(const std::vector<int>& vec) {
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

void test() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    print_vector(vec);
}

// Aspect-Oriented (AOP)

// #include <stdio.h>

#define BEFORE_PRINT() printf("Before print\n")
#define AFTER_PRINT() printf("After print\n")

void print_message() {
    BEFORE_PRINT();
    printf("Hello, AOP\n");
    AFTER_PRINT();
}

void test() {
    print_message();
}

// #include <iostream>

#define BEFORE_PRINT() std::cout << "Before print" << std::endl
#define AFTER_PRINT() std::cout << "After print" << std::endl

void print_message() {
    BEFORE_PRINT();
    std::cout << "Hello, AOP" << std::endl;
    AFTER_PRINT();
}

void test() {
    print_message();
}

// Module

// module.h
#ifndef MODULE_H
#define MODULE_H

void print_message();

#endif

// module.c
// #include "module.h"
// #include <stdio.h>

void print_message() {
    printf("Hello from module\n");
}

// main.c
// #include "module.h"

void test() {
    print_message();
}

// module.h
#ifndef MODULE_H
#define MODULE_H

class Module {
public:
    void printMessage();
};

#endif

// module.cpp
// #include "module.h"
// #include <iostream>

void Module::printMessage() {
    std::cout << "Hello from module" << std::endl;
}

// main.cpp
// #include "module.h"

void test() {
    Module module;
    module.printMessage();
}

// Middleware

// #include <stdio.h>

void middleware_1() {
    printf("Middleware 1\n");
}

void middleware_2() {
    printf("Middleware 2\n");
}

void handle_request() {
    middleware_1();
    printf("Handling request\n");
    middleware_2();
}

void test() {
    handle_request();
}

// #include <iostream>
// #include <functional>
// #include <vector>

void middleware_1() {
    std::cout << "Middleware 1" << std::endl;
}

void middleware_2() {
    std::cout << "Middleware 2" << std::endl;
}

void handle_request(const std::vector<std::function<void()>>& middlewares) {
    for (const auto& middleware : middlewares) {
        middleware();
    }
    std::cout << "Handling request" << std::endl;
}

void test() {
    std::vector<std::function<void()>> middlewares = {middleware_1, middleware_2};
    handle_request(middlewares);
}

// Promises / Async-Await

// #include <stdio.h>
// #include <stdlib.h>
// #include <unistd.h>

void async_task(void (*callback)(void)) {
    sleep(1); // Simulate async work
    callback();
}

void on_complete() {
    printf("Async task complete\n");
}

void test() {
    printf("Starting async task\n");
    async_task(on_complete);
    printf("Main function continues\n");
    sleep(2); // Wait for async task to complete
}

// #include <iostream>
// #include <future>

void async_task() {
    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate async work
    std::cout << "Async task complete" << std::endl;
}

void test() {
    std::cout << "Starting async task" << std::endl;
    std::future<void> future = std::async(std::launch::async, async_task);
    std::cout << "Main function continues" << std::endl;
    future.get(); // Wait for async task to complete
}

// Lazy Initialization

// #include <stdio.h>

int* get_instance() {
    static int* instance = NULL;
    if (instance == NULL) {
        instance = (int*)malloc(sizeof(int));
        *instance = 42; // Initialize
    }
    return instance;
}

void test() {
    int* instance = get_instance();
    printf("Instance value: %d\n", *instance);
    free(instance); // Clean up
}

// #include <iostream>

class LazyInit {
private:
    static int* instance;
public:
    static int* getInstance() {
        if (instance == nullptr) {
            instance = new int(42); // Initialize
        }
        return instance;
    }
};

int* LazyInit::instance = nullptr;

void test() {
    int* instance = LazyInit::getInstance();
    std::cout << "Instance value: " << *instance << std::endl;
    delete instance; // Clean up
}

// Callback

// #include <stdio.h>

void perform_task(void (*callback)(int)) {
    printf("Performing task\n");
    callback(42); // Callback with result
}

void callback_function(int result) {
    printf("Callback result: %d\n", result);
}

void test() {
    perform_task(callback_function);
}

// #include <iostream>
// #include <functional>

void perform_task(std::function<void(int)> callback) {
    std::cout << "Performing task" << std::endl;
    callback(42); // Callback with result
}

void callback_function(int result) {
    std::cout << "Callback result: " << result << std::endl;
}

void test() {
    perform_task(callback_function);
}

// Optional / Null Object

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    int value;
    int has_value;
} OptionalInt;

OptionalInt get_value(int valid) {
    if (valid) {
        return (OptionalInt){.value = 42, .has_value = 1};
    } else {
        return (OptionalInt){.has_value = 0};
    }
}

void test() {
    OptionalInt result = get_value(1);
    if (result.has_value) {
        printf("Value: %d\n", result.value);
    } else {
        printf("No value\n");
    }
}

// #include <iostream>
// #include <optional>

std::optional<int> get_value(bool valid) {
    if (valid) {
        return 42;
    } else {
        return std::nullopt;
    }
}

void test() {
    auto result = get_value(true);
    if (result.has_value()) {
        std::cout << "Value: " << result.value() << std::endl;
    } else {
        std::cout << "No value" << std::endl;
    }
}

// Encapsulation

// #include <stdio.h>

typedef struct {
    int data;
} Encapsulated;

void set_data(Encapsulated* e, int data) {
    e->data = data;
}

int get_data(Encapsulated* e) {
    return e->data;
}

void test() {
    Encapsulated e;
    set_data(&e, 42);
    printf("Data: %d\n", get_data(&e));
}

// #include <iostream>

class Encapsulated {
private:
    int data;
public:
    void setData(int data) {
        this->data = data;
    }
    int getData() {
        return data;
    }
};

void test() {
    Encapsulated e;
    e.setData(42);
    std::cout << "Data: " << e.getData() << std::endl;
}

// Object Composition

// #include <stdio.h>

typedef struct {
    int x, y;
} Point;

typedef struct {
    Point top_left;
    Point bottom_right;
} Rectangle;

void test() {
    Point p1 = {0, 0};
    Point p2 = {10, 10};
    Rectangle r = {p1, p2};
    printf("Rectangle from (%d, %d) to (%d, %d)\n", r.top_left.x, r.top_left.y, r.bottom_right.x, r.bottom_right.y);
}

// #include <iostream>

class Point {
public:
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

class Rectangle {
private:
    Point top_left;
    Point bottom_right;
public:
    Rectangle(Point top_left, Point bottom_right) : top_left(top_left), bottom_right(bottom_right) {}
    void print() {
        std::cout << "Rectangle from (" << top_left.x << ", " << top_left.y << ") to (" << bottom_right.x << ", " << bottom_right.y << ")" << std::endl;
    }
};

void test() {
    Point p1(0, 0);
    Point p2(10, 10);
    Rectangle r(p1, p2);
    r.print();
}

// Fluent Interface

// #include <stdio.h>

typedef struct {
    int value;
} Fluent;

Fluent* set_value(Fluent* f, int value) {
    f->value = value;
    return f;
}

void print_value(Fluent* f) {
    printf("Value: %d\n", f->value);
}

void test() {
    Fluent f;
    set_value(&f, 42)->print_value(&f);
}

// #include <iostream>

class Fluent {
private:
    int value;
public:
    Fluent& setValue(int value) {
        this->value = value;
        return *this;
    }
    void printValue() {
        std::cout << "Value: " << value << std::endl;
    }
};

void test() {
    Fluent f;
    f.setValue(42).printValue();
}

// State

// #include <stdio.h>

typedef struct State State;

struct State {
    void (*handle)(State*);
};

void handle_state_a(State* state);
void handle_state_b(State* state);

struct State {
    void (*handle)(State*);
};

void handle_state_a(State* state) {
    printf("Handling state A\n");
    state->handle = handle_state_b;
}

void handle_state_b(State* state) {
    printf("Handling state B\n");
    state->handle = handle_state_a;
}

void test() {
    State state = {handle_state_a};
    state.handle(&state);
    state.handle(&state);
    state.handle(&state);
}

// #include <iostream>

class State;

class Context {
private:
    State* state;
public:
    Context(State* state);
    void setState(State* state);
    void request();
};

class State {
public:
    virtual void handle(Context* context) = 0;
};

class StateA : public State {
public:
    void handle(Context* context) override;
};

class StateB : public State {
public:
    void handle(Context* context) override;
};

Context::Context(State* state) : state(state) {}

void Context::setState(State* state) {
    this->state = state;
}

void Context::request() {
    state->handle(this);
}

void StateA::handle(Context* context) {
    std::cout << "Handling state A" << std::endl;
    context->setState(new StateB());
}

void StateB::handle(Context* context) {
    std::cout << "Handling state B" << std::endl;
    context->setState(new StateA());
}

void test() {
    Context context(new StateA());
    context.request();
    context.request();
    context.request();
}

// Interpreter

// #include <stdio.h>
// #include <string.h>

typedef struct {
    char* text;
    int pos;
} Context;

void interpret(Context* context) {
    while (context->text[context->pos] != '\0') {
        printf("%c\n", context->text[context->pos]);
        context->pos++;
    }
}

void test() {
    Context context = {"Hello", 0};
    interpret(&context);
}

// #include <iostream>
// #include <string>

class Context {
private:
    std::string text;
    size_t pos;
public:
    Context(std::string text) : text(text), pos(0) {}
    char next() {
        if (pos < text.length()) {
            return text[pos++];
        }
        return '\0';
    }
};

class Expression {
public:
    virtual void interpret(Context* context) = 0;
};

class CharExpression : public Expression {
public:
    void interpret(Context* context) override {
        char c;
        while ((c = context->next()) != '\0') {
            std::cout << c << std::endl;
        }
    }
};

void test() {
    Context context("Hello");
    CharExpression expr;
    expr.interpret(&context);
}

// Dependency Injection

// #include <stdio.h>

typedef struct {
    void (*send_message)(const char* message);
} Service;

void send_message(const char* message) {
    printf("Message: %s\n", message);
}

typedef struct {
    Service* service;
} Client;

void client_send(Client* client, const char* message) {
    client->service->send_message(message);
}

void test() {
    Service service = {send_message};
    Client client = {&service};
    client_send(&client, "Hello, DI");
}

// #include <iostream>

class Service {
public:
    virtual void sendMessage(const std::string& message) = 0;
};

class ConcreteService : public Service {
public:
    void sendMessage(const std::string& message) override {
        std::cout << "Message: " << message << std::endl;
    }
};

class Client {
private:
    Service* service;
public:
    Client(Service* service) : service(service) {}
    void send(const std::string& message) {
        service->sendMessage(message);
    }
};

void test() {
    ConcreteService service;
    Client client(&service);
    client.send("Hello, DI");
}

// Data Access Object (DAO)

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} User;

typedef struct {
    User users[10];
    int count;
} UserDao;

void user_dao_init(UserDao* dao) {
    dao->count = 0;
}

void user_dao_add(UserDao* dao, User user) {
    dao->users[dao->count++] = user;
}

User* user_dao_get(UserDao* dao, int id) {
    for (int i = 0; i < dao->count; i++) {
        if (dao->users[i].id == id) {
            return &dao->users[i];
        }
    }
    return NULL;
}

void test() {
    UserDao dao;
    user_dao_init(&dao);

    User user1 = {1, "Alice"};
    User user2 = {2, "Bob"};
    user_dao_add(&dao, user1);
    user_dao_add(&dao, user2);

    User* user = user_dao_get(&dao, 1);
    if (user) {
        printf("User: %d, %s\n", user->id, user->name);
    } else {
        printf("User not found\n");
    }
}

// #include <iostream>
// #include <vector>
// #include <string>

class User {
public:
    int id;
    std::string name;
    User(int id, std::string name) : id(id), name(name) {}
};

class UserDao {
private:
    std::vector<User> users;
public:
    void add(User user) {
        users.push_back(user);
    }
    User* get(int id) {
        for (auto& user : users) {
            if (user.id == id) {
                return &user;
            }
        }
        return nullptr;
    }
};

void test() {
    UserDao dao;
    dao.add(User(1, "Alice"));
    dao.add(User(2, "Bob"));

    User* user = dao.get(1);
    if (user) {
        std::cout << "User: " << user->id << ", " << user->name << std::endl;
    } else {
        std::cout << "User not found" << std::endl;
    }
}

// Data Transfer Object (DTO)

// #include <stdio.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} UserDTO;

UserDTO create_user_dto(int id, const char* name) {
    UserDTO dto;
    dto.id = id;
    strcpy(dto.name, name);
    return dto;
}

void test() {
    UserDTO user = create_user_dto(1, "Alice");
    printf("UserDTO: %d, %s\n", user.id, user.name);
}

// #include <iostream>
// #include <string>

class UserDTO {
public:
    int id;
    std::string name;
    UserDTO(int id, std::string name) : id(id), name(name) {}
};

void test() {
    UserDTO user(1, "Alice");
    std::cout << "UserDTO: " << user.id << ", " << user.name << std::endl;
}

// Service Locator

// #include <stdio.h>

typedef struct {
    void (*print_message)(const char*);
} Service;

Service* service_locator_get_service() {
    static Service service = {NULL};
    if (service.print_message == NULL) {
        service.print_message = [](const char* message) {
            printf("Service: %s\n", message);
        };
    }
    return &service;
}

void test() {
    Service* service = service_locator_get_service();
    service->print_message("Hello, Service Locator");
}

// #include <iostream>
// #include <memory>

class Service {
public:
    virtual void printMessage(const std::string& message) = 0;
};

class ConcreteService : public Service {
public:
    void printMessage(const std::string& message) override {
        std::cout << "Service: " << message << std::endl;
    }
};

class ServiceLocator {
private:
    static std::unique_ptr<Service> service;
public:
    static Service* getService() {
        if (!service) {
            service = std::make_unique<ConcreteService>();
        }
        return service.get();
    }
};

std::unique_ptr<Service> ServiceLocator::service = nullptr;

void test() {
    Service* service = ServiceLocator::getService();
    service->printMessage("Hello, Service Locator");
}

// Repository

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} User;

typedef struct {
    User users[10];
    int count;
} UserRepository;

void user_repository_init(UserRepository* repo) {
    repo->count = 0;
}

void user_repository_add(UserRepository* repo, User user) {
    repo->users[repo->count++] = user;
}

User* user_repository_get(UserRepository* repo, int id) {
    for (int i = 0; i < repo->count; i++) {
        if (repo->users[i].id == id) {
            return &repo->users[i];
        }
    }
    return NULL;
}

void test() {
    UserRepository repo;
    user_repository_init(&repo);

    User user1 = {1, "Alice"};
    User user2 = {2, "Bob"};
    user_repository_add(&repo, user1);
    user_repository_add(&repo, user2);

    User* user = user_repository_get(&repo, 1);
    if (user) {
        printf("User: %d, %s\n", user->id, user->name);
    } else {
        printf("User not found\n");
    }
}

// #include <iostream>
// #include <vector>
// #include <string>

class User {
public:
    int id;
    std::string name;
    User(int id, std::string name) : id(id), name(name) {}
};

class UserRepository {
private:
    std::vector<User> users;
public:
    void add(User user) {
        users.push_back(user);
    }
    User* get(int id) {
        for (auto& user : users) {
            if (user.id == id) {
                return &user;
            }
        }
        return nullptr;
    }
};

void test() {
    UserRepository repo;
    repo.add(User(1, "Alice"));
    repo.add(User(2, "Bob"));

    User* user = repo.get(1);
    if (user) {
        std::cout << "User: " << user->id << ", " << user->name << std::endl;
    } else {
        std::cout << "User not found" << std::endl;
    }
}

// Active Record

// #include <stdio.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} User;

void user_save(User* user) {
    printf("Saving user: %d, %s\n", user->id, user->name);
}

void user_load(User* user, int id) {
    user->id = id;
    strcpy(user->name, "Loaded User");
}

void test() {
    User user = {1, "Alice"};
    user_save(&user);
    User loaded_user;
    user_load(&loaded_user, 1);
    printf("Loaded user: %d, %s\n", loaded_user.id, loaded_user.name);
}

// #include <iostream>
// #include <string>

class User {
public:
    int id;
    std::string name;
    User(int id, std::string name) : id(id), name(name) {}
    void save() {
        std::cout << "Saving user: " << id << ", " << name << std::endl;
    }
    static User load(int id) {
        return User(id, "Loaded User");
    }
};

void test() {
    User user(1, "Alice");
    user.save();
    User loaded_user = User::load(1);
    std::cout << "Loaded user: " << loaded_user.id << ", " << loaded_user.name << std::endl;
}

// Event Aggregator

// #include <stdio.h>

typedef void (*EventHandler)(const char*);

typedef struct {
    EventHandler handlers[10];
    int count;
} EventAggregator;

void event_aggregator_add_handler(EventAggregator* aggregator, EventHandler handler) {
    aggregator->handlers[aggregator->count++] = handler;
}

void event_aggregator_publish(EventAggregator* aggregator, const char* message) {
    for (int i = 0; i < aggregator->count; i++) {
        aggregator->handlers[i](message);
    }
}

void handle_event(const char* message) {
    printf("Event received: %s\n", message);
}

void test() {
    EventAggregator aggregator = {0};
    event_aggregator_add_handler(&aggregator, handle_event);
    event_aggregator_publish(&aggregator, "Hello, Event Aggregator");
}

// #include <iostream>
// #include <vector>
// #include <functional>

class EventAggregator {
private:
    std::vector<std::function<void(const std::string&)>> handlers;
public:
    void addHandler(std::function<void(const std::string&)> handler) {
        handlers.push_back(handler);
    }
    void publish(const std::string& message) {
        for (const auto& handler : handlers) {
            handler(message);
        }
    }
};

void handleEvent(const std::string& message) {
    std::cout << "Event received: " << message << std::endl;
}

void test() {
    EventAggregator aggregator;
    aggregator.addHandler(handleEvent);
    aggregator.publish("Hello, Event Aggregator");
}

// Specification

// #include <stdio.h>
// #include <stdbool.h>

typedef struct {
    int id;
    char name[50];
    int age;
} User;

typedef bool (*Specification)(User);

bool is_adult(User user) {
    return user.age >= 18;
}

void print_users(User users[], int size, Specification spec) {
    for (int i = 0; i < size; i++) {
        if (spec(users[i])) {
            printf("User: %d, %s, %d\n", users[i].id, users[i].name, users[i].age);
        }
    }
}

void test() {
    User users[] = {{1, "Alice", 17}, {2, "Bob", 20}};
    print_users(users, 2, is_adult);
}

// #include <iostream>
// #include <vector>
// #include <string>
// #include <functional>

class User {
public:
    int id;
    std::string name;
    int age;
    User(int id, std::string name, int age) : id(id), name(name), age(age) {}
};

bool isAdult(User user) {
    return user.age >= 18;
}

void printUsers(std::vector<User>& users, std::function<bool(User)> spec) {
    for (const auto& user : users) {
        if (spec(user)) {
            std::cout << "User: " << user.id << ", " << user.name << ", " << user.age << std::endl;
        }
    }
}

void test() {
    std::vector<User> users = {User(1, "Alice", 17), User(2, "Bob", 20)};
    printUsers(users, isAdult);
}

// Event-Driven

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    void (*callback)(const char*);
} EventHandler;

void raise_event(EventHandler* handler, const char* message) {
    if (handler->callback) {
        handler->callback(message);
    }
}

void on_event(const char* message) {
    printf("Event received: %s\n", message);
}

void test() {
    EventHandler handler;
    handler.callback = on_event;
    raise_event(&handler, "Hello, Event-Driven");
}

// #include <iostream>
// #include <functional>

class Event {
private:
    std::function<void(const std::string&)> callback;
public:
    void setCallback(std::function<void(const std::string&)> cb) {
        callback = cb;
    }
    void raise(const std::string& message) {
        if (callback) {
            callback(message);
        }
    }
};

void onEvent(const std::string& message) {
    std::cout << "Event received: " << message << std::endl;
}

void test() {
    Event event;
    event.setCallback(onEvent);
    event.raise("Hello, Event-Driven");
}

// Singleton

// #include <stdio.h>

typedef struct {
    int value;
} Singleton;

Singleton* get_instance() {
    static Singleton instance = {0};
    return &instance;
}

void test() {
    Singleton* singleton = get_instance();
    singleton->value = 42;
    printf("Singleton value: %d\n", singleton->value);
}

// #include <iostream>

class Singleton {
private:
    static Singleton* instance;
    int value;
    Singleton() : value(0) {}
public:
    static Singleton* getInstance() {
        if (!instance) {
            instance = new Singleton();
        }
        return instance;
    }
    void setValue(int val) {
        value = val;
    }
    int getValue() const {
        return value;
    }
};

Singleton* Singleton::instance = nullptr;

void test() {
    Singleton* singleton = Singleton::getInstance();
    singleton->setValue(42);
    std::cout << "Singleton value: " << singleton->getValue() << std::endl;
}

// Factory

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    int id;
    char name[50];
} Product;

Product* create_product(int id, const char* name) {
    Product* product = (Product*)malloc(sizeof(Product));
    product->id = id;
    strcpy(product->name, name);
    return product;
}

void test() {
    Product* product = create_product(1, "Widget");
    printf("Product: %d, %s\n", product->id, product->name);
    free(product);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Product {
public:
    int id;
    std::string name;
    Product(int id, std::string name) : id(id), name(name) {}
};

class ProductFactory {
public:
    static std::unique_ptr<Product> createProduct(int id, std::string name) {
        return std::make_unique<Product>(id, name);
    }
};

void test() {
    std::unique_ptr<Product> product = ProductFactory::createProduct(1, "Widget");
    std::cout << "Product: " << product->id << ", " << product->name << std::endl;
}

// Prototype

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} Prototype;

Prototype* clone_prototype(Prototype* prototype) {
    Prototype* new_prototype = (Prototype*)malloc(sizeof(Prototype));
    new_prototype->id = prototype->id;
    strcpy(new_prototype->name, prototype->name);
    return new_prototype;
}

void test() {
    Prototype prototype = {1, "Original"};
    Prototype* clone = clone_prototype(&prototype);
    printf("Cloned Prototype: %d, %s\n", clone->id, clone->name);
    free(clone);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Prototype {
public:
    int id;
    std::string name;
    Prototype(int id, std::string name) : id(id), name(name) {}
    std::unique_ptr<Prototype> clone() const {
        return std::make_unique<Prototype>(id, name);
    }
};

void test() {
    Prototype prototype(1, "Original");
    std::unique_ptr<Prototype> clone = prototype.clone();
    std::cout << "Cloned Prototype: " << clone->id << ", " << clone->name << std::endl;
}

// Abstract Factory

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
} Product;

typedef struct {
    Product* (*create_product)(int id, const char* name);
} ProductFactory;

Product* create_widget(int id, const char* name) {
    Product* product = (Product*)malloc(sizeof(Product));
    product->id = id;
    strcpy(product->name, name);
    return product;
}

ProductFactory* create_widget_factory() {
    ProductFactory* factory = (ProductFactory*)malloc(sizeof(ProductFactory));
    factory->create_product = create_widget;
    return factory;
}

void test() {
    ProductFactory* factory = create_widget_factory();
    Product* product = factory->create_product(1, "Widget");
    printf("Product: %d, %s\n", product->id, product->name);
    free(product);
    free(factory);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Product {
public:
    int id;
    std::string name;
    Product(int id, std::string name) : id(id), name(name) {}
};

class ProductFactory {
public:
    virtual std::unique_ptr<Product> createProduct(int id, std::string name) = 0;
};

class WidgetFactory : public ProductFactory {
public:
    std::unique_ptr<Product> createProduct(int id, std::string name) override {
        return std::make_unique<Product>(id, name);
    }
};

void test() {
    std::unique_ptr<ProductFactory> factory = std::make_unique<WidgetFactory>();
    std::unique_ptr<Product> product = factory->createProduct(1, "Widget");
    std::cout << "Product: " << product->id << ", " << product->name << std::endl;
}

// Builder

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    int id;
    char name[50];
    char description[100];
} Product;

typedef struct {
    Product product;
} ProductBuilder;

ProductBuilder* create_builder() {
    ProductBuilder* builder = (ProductBuilder*)malloc(sizeof(ProductBuilder));
    builder->product.id = 0;
    strcpy(builder->product.name, "");
    strcpy(builder->product.description, "");
    return builder;
}

void set_id(ProductBuilder* builder, int id) {
    builder->product.id = id;
}

void set_name(ProductBuilder* builder, const char* name) {
    strcpy(builder->product.name, name);
}

void set_description(ProductBuilder* builder, const char* description) {
    strcpy(builder->product.description, description);
}

Product build(ProductBuilder* builder) {
    return builder->product;
}

void test() {
    ProductBuilder* builder = create_builder();
    set_id(builder, 1);
    set_name(builder, "Widget");
    set_description(builder, "A useful widget");
    Product product = build(builder);
    printf("Product: %d, %s, %s\n", product.id, product.name, product.description);
    free(builder);
}

// #include <iostream>
// #include <string>

class Product {
public:
    int id;
    std::string name;
    std::string description;

    class Builder {
    private:
        Product product;
    public:
        Builder& setId(int id) {
            product.id = id;
            return *this;
        }
        Builder& setName(const std::string& name) {
            product.name = name;
            return *this;
        }
        Builder& setDescription(const std::string& description) {
            product.description = description;
            return *this;
        }
        Product build() {
            return product;
        }
    };
};

void test() {
    Product product = Product::Builder().setId(1).setName("Widget").setDescription("A useful widget").build();
    std::cout << "Product: " << product.id << ", " << product.name << ", " << product.description << std::endl;
}

// Decorator

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    char description[100];
    double (*cost)(void);
} Beverage;

double base_cost() {
    return 1.0;
}

Beverage* create_beverage(const char* description, double (*cost)()) {
    Beverage* beverage = (Beverage*)malloc(sizeof(Beverage));
    strcpy(beverage->description, description);
    beverage->cost = cost;
    return beverage;
}

double milk_cost() {
    return base_cost() + 0.5;
}

void test() {
    Beverage* coffee = create_beverage("Coffee", base_cost);
    printf("%s: $%.2f\n", coffee->description, coffee->cost());

    Beverage* milk = create_beverage("Milk", milk_cost);
    printf("%s: $%.2f\n", milk->description, milk->cost());

    free(coffee);
    free(milk);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Beverage {
public:
    virtual std::string getDescription() const = 0;
    virtual double cost() const = 0;
    virtual ~Beverage() = default;
};

class Coffee : public Beverage {
public:
    std::string getDescription() const override {
        return "Coffee";
    }
    double cost() const override {
        return 1.0;
    }
};

class MilkDecorator : public Beverage {
private:
    std::unique_ptr<Beverage> beverage;
public:
    MilkDecorator(std::unique_ptr<Beverage> bev) : beverage(std::move(bev)) {}
    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }
    double cost() const override {
        return beverage->cost() + 0.5;
    }
};

void test() {
    std::unique_ptr<Beverage> coffee = std::make_unique<Coffee>();
    std::cout << coffee->getDescription() << ": $" << coffee->cost() << std::endl;

    std::unique_ptr<Beverage> milk = std::make_unique<MilkDecorator>(std::move(coffee));
    std::cout << milk->getDescription() << ": $" << milk->cost() << std::endl;

}

// Adapter

// #include <stdio.h>

typedef struct {
    int x;
    int y;
} LegacyPoint;

void legacy_draw(LegacyPoint point) {
    printf("Drawing point at (%d, %d)\n", point.x, point.y);
}

typedef struct {
    int x;
    int y;
} Point;

void draw(Point* point) {
    LegacyPoint legacy_point = {point->x, point->y};
    legacy_draw(legacy_point);
}

void test() {
    Point point = {10, 20};
    draw(&point);
}

// #include <iostream>

class LegacyRectangle {
public:
    void legacyDraw(int x1, int y1, int x2, int y2) {
        std::cout << "Drawing rectangle from (" << x1 << ", " << y1 << ") to (" << x2 << ", " << y2 << ")" << std::endl;
    }
};

class Rectangle {
public:
    virtual void draw(int x, int y, int width, int height) = 0;
};

class RectangleAdapter : public Rectangle {
private:
    LegacyRectangle legacyRectangle;
public:
    void draw(int x, int y, int width, int height) override {
        legacyRectangle.legacyDraw(x, y, x + width, y + height);
    }
};

void test() {
    RectangleAdapter adapter;
    adapter.draw(10, 20, 30, 40);
}

// Composite

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct Component {
    char name[50];
    void (*operation)(struct Component*);
    struct Component* children[10];
    int child_count;
} Component;

void leaf_operation(Component* component) {
    printf("Leaf: %s\n", component->name);
}

void composite_operation(Component* component) {
    printf("Composite: %s\n", component->name);
    for (int i = 0; i < component->child_count; i++) {
        component->children[i]->operation(component->children[i]);
    }
}

Component* create_component(const char* name, void (*operation)(Component*)) {
    Component* component = (Component*)malloc(sizeof(Component));
    strcpy(component->name, name);
    component->operation = operation;
    component->child_count = 0;
    return component;
}

void add_child(Component* parent, Component* child) {
    parent->children[parent->child_count++] = child;
}

void test() {
    Component* root = create_component("root", composite_operation);
    Component* leaf1 = create_component("leaf1", leaf_operation);
    Component* leaf2 = create_component("leaf2", leaf_operation);

    add_child(root, leaf1);
    add_child(root, leaf2);

    root->operation(root);

    free(root);
    free(leaf1);
    free(leaf2);
}

// #include <iostream>
// #include <vector>
// #include <memory>

class Component {
public:
    virtual void operation() const = 0;
    virtual void add(std::shared_ptr<Component> component) {}
    virtual ~Component() = default;
};

class Leaf : public Component {
private:
    std::string name;
public:
    Leaf(const std::string& name) : name(name) {}
    void operation() const override {
        std::cout << "Leaf: " << name << std::endl;
    }
};

class Composite : public Component {
private:
    std::string name;
    std::vector<std::shared_ptr<Component>> children;
public:
    Composite(const std::string& name) : name(name) {}
    void operation() const override {
        std::cout << "Composite: " << name << std::endl;
        for (const auto& child : children) {
            child->operation();
        }
    }
    void add(std::shared_ptr<Component> component) override {
        children.push_back(component);
    }
};

void test() {
    std::shared_ptr<Component> root = std::make_shared<Composite>("root");
    std::shared_ptr<Component> leaf1 = std::make_shared<Leaf>("leaf1");
    std::shared_ptr<Component> leaf2 = std::make_shared<Leaf>("leaf2");

    root->add(leaf1);
    root->add(leaf2);

    root->operation();
}

// Flyweight

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    char data[100];
} Flyweight;

Flyweight* create_flyweight(const char* data) {
    Flyweight* flyweight = (Flyweight*)malloc(sizeof(Flyweight));
    strcpy(flyweight->data, data);
    return flyweight;
}

void use_flyweight(Flyweight* flyweight) {
    printf("Using flyweight: %s\n", flyweight->data);
}

void test() {
    Flyweight* flyweight1 = create_flyweight("Shared Data");
    Flyweight* flyweight2 = create_flyweight("Shared Data");

    use_flyweight(flyweight1);
    use_flyweight(flyweight2);

    free(flyweight1);
    free(flyweight2);
}

// #include <iostream>
// #include <unordered_map>
// #include <memory>

class Flyweight {
private:
    std::string data;
public:
    Flyweight(const std::string& data) : data(data) {}
    void operation() const {
        std::cout << "Using flyweight: " << data << std::endl;
    }
};

class FlyweightFactory {
private:
    std::unordered_map<std::string, std::shared_ptr<Flyweight>> flyweights;
public:
    std::shared_ptr<Flyweight> getFlyweight(const std::string& data) {
        if (flyweights.find(data) == flyweights.end()) {
            flyweights[data] = std::make_shared<Flyweight>(data);
        }
        return flyweights[data];
    }
};

void test() {
    FlyweightFactory factory;

    auto flyweight1 = factory.getFlyweight("Shared Data");
    auto flyweight2 = factory.getFlyweight("Shared Data");

    flyweight1->operation();
    flyweight2->operation();

}

// Proxy

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    void (*request)();
} RealSubject;

void real_request() {
    printf("RealSubject: Handling request\n");
}

typedef struct {
    RealSubject* real_subject;
    void (*request)();
} Proxy;

void proxy_request() {
    printf("Proxy: Forwarding request to RealSubject\n");
    real_subject->request();
}

Proxy* create_proxy(RealSubject* real_subject) {
    Proxy* proxy = (Proxy*)malloc(sizeof(Proxy));
    proxy->real_subject = real_subject;
    proxy->request = proxy_request;
    return proxy;
}

void test() {
    RealSubject real_subject = {real_request};
    Proxy* proxy = create_proxy(&real_subject);
    proxy->request();
    free(proxy);
}

// #include <iostream>
// #include <memory>

class RealSubject {
public:
    virtual void request() const {
        std::cout << "RealSubject: Handling request" << std::endl;
    }
};

class Proxy : public RealSubject {
private:
    std::shared_ptr<RealSubject> realSubject;
public:
    Proxy(std::shared_ptr<RealSubject> realSubject) : realSubject(realSubject) {}
    void request() const override {
        std::cout << "Proxy: Forwarding request to RealSubject" << std::endl;
        realSubject->request();
    }
};

void test() {
    std::shared_ptr<RealSubject> realSubject = std::make_shared<RealSubject>();
    Proxy proxy(realSubject);
    proxy.request();
}

// Observer

// #include <stdio.h>
// #include <stdlib.h>

typedef struct Observer {
    void (*update)(int);
} Observer;

typedef struct Subject {
    Observer** observers;
    int observer_count;
    int state;
} Subject;

void notify_observers(Subject* subject) {
    for (int i = 0; i < subject->observer_count; i++) {
        subject->observers[i]->update(subject->state);
    }
}

void set_state(Subject* subject, int state) {
    subject->state = state;
    notify_observers(subject);
}

void observer_update(int state) {
    printf("Observer notified of state change to %d\n", state);
}

void test() {
    Subject subject = {NULL, 0, 0};
    Observer observer = {observer_update};

    subject.observers = (Observer**)malloc(sizeof(Observer*));
    subject.observers[0] = &observer;
    subject.observer_count = 1;

    set_state(&subject, 42);

    free(subject.observers);
}

// #include <iostream>
// #include <vector>
// #include <memory>

class Observer {
public:
    virtual void update(int state) = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    std::vector<std::shared_ptr<Observer>> observers;
    int state;
public:
    void attach(std::shared_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    void setState(int newState) {
        state = newState;
        notify();
    }
    void notify() {
        for (auto& observer : observers) {
            observer->update(state);
        }
    }
};

class ConcreteObserver : public Observer {
public:
    void update(int state) override {
        std::cout << "Observer notified of state change to " << state << std::endl;
    }
};

void test() {
    auto subject = std::make_shared<Subject>();
    auto observer = std::make_shared<ConcreteObserver>();

    subject->attach(observer);
    subject->setState(42);

}

// Command

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    void (*execute)();
} Command;

void print_command() {
    printf("Command executed\n");
}

void test() {
    Command command = {print_command};
    command.execute();
}

// #include <iostream>
// #include <functional>

class Command {
public:
    virtual void execute() const = 0;
    virtual ~Command() = default;
};

class PrintCommand : public Command {
public:
    void execute() const override {
        std::cout << "Command executed" << std::endl;
    }
};

void test() {
    PrintCommand command;
    command.execute();
}

// Strategy

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    int (*strategy)(int, int);
} StrategyContext;

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

void test() {
    StrategyContext context;
    context.strategy = add;
    printf("Addition: %d\n", context.strategy(5, 3));

    context.strategy = subtract;
    printf("Subtraction: %d\n", context.strategy(5, 3));

}

// #include <iostream>
// #include <functional>

class StrategyContext {
private:
    std::function<int(int, int)> strategy;
public:
    void setStrategy(std::function<int(int, int)> str) {
        strategy = str;
    }
    int execute(int a, int b) const {
        return strategy(a, b);
    }
};

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

void test() {
    StrategyContext context;
    context.setStrategy(add);
    std::cout << "Addition: " << context.execute(5, 3) << std::endl;

    context.setStrategy(subtract);
    std::cout << "Subtraction: " << context.execute(5, 3) << std::endl;

}

// Iterator

// #include <stdio.h>

typedef struct {
    int* items;
    int size;
    int index;
} Iterator;

int next(Iterator* iterator) {
    if (iterator->index < iterator->size) {
        return iterator->items[iterator->index++];
    }
    return -1; // End of iteration
}

void test() {
    int items[] = {1, 2, 3, 4, 5};
    Iterator iterator = {items, 5, 0};

    int value;
    while ((value = next(&iterator)) != -1) {
        printf("%d\n", value);
    }

}

// #include <iostream>
// #include <vector>

class Iterator {
private:
    std::vector<int>::iterator current;
    std::vector<int>::iterator end;
public:
    Iterator(std::vector<int>::iterator start, std::vector<int>::iterator end)
        : current(start), end(end) {}

    bool hasNext() const {
        return current != end;
    }

    int next() {
        return *current++;
    }
};

void test() {
    std::vector<int> items = {1, 2, 3, 4, 5};
    Iterator iterator(items.begin(), items.end());

    while (iterator.hasNext()) {
        std::cout << iterator.next() << std::endl;
    }

}

// Template

// #include <stdio.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))

void test() {
    int a = 5, b = 10;
    printf("Max of %d and %d is %d\n", a, b, MAX(a, b));

    float x = 5.5, y = 10.1;
    printf("Max of %.2f and %.2f is %.2f\n", x, y, MAX(x, y));

}

// #include <iostream>

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

void test() {
    int a = 5, b = 10;
    std::cout << "Max of " << a << " and " << b << " is " << max(a, b) << std::endl;

    double x = 5.5, y = 10.1;
    std::cout << "Max of " << x << " and " << y << " is " << max(x, y) << std::endl;

}
continue
ChatGPT
Sure, let’s continue with more coding styles and patterns in C and C++.


// Mediator

// #include <stdio.h>
// #include <stdlib.h>

typedef struct Mediator Mediator;

typedef struct {
    Mediator* mediator;
    void (*sendMessage)(const char*);
    void (*receiveMessage)(const char*);
} Colleague;

struct Mediator {
    Colleague* colleague1;
    Colleague* colleague2;
    void (*mediate)(const char*);
};

void send_message(const char* message) {
    printf("Sending message: %s\n", message);
}

void receive_message(const char* message) {
    printf("Received message: %s\n", message);
}

void mediate(const char* message) {
    printf("Mediator: Relaying message: %s\n", message);
}

void test() {
    Mediator mediator = {NULL, NULL, mediate};
    Colleague colleague1 = {&mediator, send_message, receive_message};
    Colleague colleague2 = {&mediator, send_message, receive_message};

    mediator.colleague1 = &colleague1;
    mediator.colleague2 = &colleague2;

    colleague1.sendMessage("Hello from Colleague1");
    colleague2.receiveMessage("Hello from Colleague1");

}

// #include <iostream>
// #include <memory>

class Mediator;

class Colleague {
protected:
    Mediator* mediator;
public:
    Colleague(Mediator* med) : mediator(med) {}
    virtual void send(const std::string& message) = 0;
    virtual void receive(const std::string& message) = 0;
    virtual ~Colleague() = default;
};

class Mediator {
private:
    Colleague* colleague1;
    Colleague* colleague2;
public:
    void setColleagues(Colleague* c1, Colleague* c2) {
        colleague1 = c1;
        colleague2 = c2;
    }
    void mediate(const std::string& message) {
        std::cout << "Mediator: Relaying message: " << message << std::endl;
        colleague2->receive(message);
    }
};

class ConcreteColleague1 : public Colleague {
public:
    ConcreteColleague1(Mediator* med) : Colleague(med) {}
    void send(const std::string& message) override {
        std::cout << "ConcreteColleague1: Sending message: " << message << std::endl;
        mediator->mediate(message);
    }
    void receive(const std::string& message) override {
        std::cout << "ConcreteColleague1: Received message: " << message << std::endl;
    }
};

class ConcreteColleague2 : public Colleague {
public:
    ConcreteColleague2(Mediator* med) : Colleague(med) {}
    void send(const std::string& message) override {
        std::cout << "ConcreteColleague2: Sending message: " << message << std::endl;
        mediator->mediate(message);
    }
    void receive(const std::string& message) override {
        std::cout << "ConcreteColleague2: Received message: " << message << std::endl;
    }
};

void test() {
    Mediator mediator;
    ConcreteColleague1 colleague1(&mediator);
    ConcreteColleague2 colleague2(&mediator);

    mediator.setColleagues(&colleague1, &colleague2);

    colleague1.send("Hello from Colleague1");
}

// Memento

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    char* state;
} Memento;

typedef struct {
    char* state;
} Originator;

Memento* create_memento(Originator* originator) {
    Memento* memento = (Memento*)malloc(sizeof(Memento));
    memento->state = strdup(originator->state);
    return memento;
}

void restore_state(Originator* originator, Memento* memento) {
    free(originator->state);
    originator->state = strdup(memento->state);
}

void test() {
    Originator originator = {"Initial State"};
    Memento* memento = create_memento(&originator);

    printf("Current State: %s\n", originator.state);
    originator.state = "Changed State";
    printf("Changed State: %s\n", originator.state);

    restore_state(&originator, memento);
    printf("Restored State: %s\n", originator.state);

    free(memento->state);
    free(memento);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Memento {
private:
    std::string state;
public:
    Memento(const std::string& state) : state(state) {}
    std::string getState() const { return state; }
};

class Originator {
private:
    std::string state;
public:
    void setState(const std::string& newState) {
        state = newState;
    }
    std::string getState() const {
        return state;
    }
    std::shared_ptr<Memento> saveStateToMemento() {
        return std::make_shared<Memento>(state);
    }
    void getStateFromMemento(const std::shared_ptr<Memento>& memento) {
        state = memento->getState();
    }
};

void test() {
    Originator originator;
    originator.setState("Initial State");
    auto memento = originator.saveStateToMemento();

    std::cout << "Current State: " << originator.getState() << std::endl;
    originator.setState("Changed State");
    std::cout << "Changed State: " << originator.getState() << std::endl;

    originator.getStateFromMemento(memento);
    std::cout << "Restored State: " << originator.getState() << std::endl;

}

// Visitor

// #include <stdio.h>

typedef struct Element Element;
typedef struct Visitor Visitor;

typedef void (*AcceptFunc)(Element*, Visitor*);

struct Element {
    AcceptFunc accept;
};

typedef void (*VisitFunc)(Element*);

struct Visitor {
    VisitFunc visit;
};

void visit(Element* element) {
    printf("Visiting element\n");
}

void accept(Element* element, Visitor* visitor) {
    visitor->visit(element);
}

void test() {
    Element element = {accept};
    Visitor visitor = {visit};

    accept(&element, &visitor);

}

// #include <iostream>
// #include <memory>

class Element; // Forward declaration

class Visitor {
public:
    virtual void visit(Element* element) = 0;
    virtual ~Visitor() = default;
};

class Element {
public:
    virtual void accept(Visitor* visitor) = 0;
    virtual ~Element() = default;
};

class ConcreteElement : public Element {
public:
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
};

class ConcreteVisitor : public Visitor {
public:
    void visit(Element* element) override {
        std::cout << "Visiting concrete element" << std::endl;
    }
};

void test() {
    ConcreteElement element;
    ConcreteVisitor visitor;

    element.accept(&visitor);

}

// Chain of Responsibility

// #include <stdio.h>

typedef struct Handler Handler;

struct Handler {
    Handler* next;
    void (*handleRequest)(Handler*, int);
};

void handle_request(Handler* handler, int request) {
    if (handler->next) {
        handler->next->handleRequest(handler->next, request);
    } else {
        printf("Request %d handled by last handler\n", request);
    }
}

void test() {
    Handler handler1 = {NULL, handle_request};
    Handler handler2 = {&handler1, handle_request};

    handler2.handleRequest(&handler2, 5);

}

// #include <iostream>
// #include <memory>

class Handler {
protected:
    std::shared_ptr<Handler> next;
public:
    void setNext(std::shared_ptr<Handler> handler) {
        next = handler;
    }
    virtual void handleRequest(int request) {
        if (next) {
            next->handleRequest(request);
        } else {
            std::cout << "Request " << request << " handled by last handler" << std::endl;
        }
    }
    virtual ~Handler() = default;
};

class ConcreteHandler1 : public Handler {
public:
    void handleRequest(int request) override {
        if (request < 10) {
            std::cout << "ConcreteHandler1 handling request " << request << std::endl;
        } else {
            Handler::handleRequest(request);
        }
    }
};

class ConcreteHandler2 : public Handler {
public:
    void handleRequest(int request) override {
        if (request >= 10) {
            std::cout << "ConcreteHandler2 handling request " << request << std::endl;
        } else {
            Handler::handleRequest(request);
        }
    }
};

void test() {
    auto handler1 = std::make_shared<ConcreteHandler1>();
    auto handler2 = std::make_shared<ConcreteHandler2>();
    
    handler1->setNext(handler2);

    handler1->handleRequest(5);
    handler1->handleRequest(15);

}

// Facade

// #include <stdio.h>

typedef struct {
    int value;
} Subsystem1;

typedef struct {
    int value;
} Subsystem2;

typedef struct {
    Subsystem1* subsystem1;
    Subsystem2* subsystem2;
} Facade;

int operation1(Subsystem1* subsystem) {
    return subsystem->value * 2;
}

int operation2(Subsystem2* subsystem) {
    return subsystem->value + 5;
}

Facade* create_facade(int value1, int value2) {
    Facade* facade = (Facade*)malloc(sizeof(Facade));
    facade->subsystem1 = (Subsystem1*)malloc(sizeof(Subsystem1));
    facade->subsystem2 = (Subsystem2*)malloc(sizeof(Subsystem2));
    facade->subsystem1->value = value1;
    facade->subsystem2->value = value2;
    return facade;
}

void facade_operation(Facade* facade) {
    int result1 = operation1(facade->subsystem1);
    int result2 = operation2(facade->subsystem2);
    printf("Facade operation results: %d, %d\n", result1, result2);
}

void destroy_facade(Facade* facade) {
    free(facade->subsystem1);
    free(facade->subsystem2);
    free(facade);
}

void test() {
    Facade* facade = create_facade(10, 20);
    facade_operation(facade);
    destroy_facade(facade);
}

// #include <iostream>

class Subsystem1 {
public:
    int value;
    Subsystem1(int val) : value(val) {}
    int operation1() const {
        return value * 2;
    }
};

class Subsystem2 {
public:
    int value;
    Subsystem2(int val) : value(val) {}
    int operation2() const {
        return value + 5;
    }
};

class Facade {
private:
    Subsystem1 subsystem1;
    Subsystem2 subsystem2;
public:
    Facade(int val1, int val2) : subsystem1(val1), subsystem2(val2) {}
    void operation() const {
        int result1 = subsystem1.operation1();
        int result2 = subsystem2.operation2();
        std::cout << "Facade operation results: " << result1 << ", " << result2 << std::endl;
    }
};

void test() {
    Facade facade(10, 20);
    facade.operation();
}

// Bridge

// #include <stdio.h>

typedef struct {
    void (*draw)(const char*);
} DrawingAPI;

typedef struct {
    DrawingAPI* api;
    void (*draw)(const char*);
} Shape;

void draw_circle(const char* api_name) {
    printf("Drawing Circle using %s\n", api_name);
}

void draw_square(const char* api_name) {
    printf("Drawing Square using %s\n", api_name);
}

DrawingAPI circle_api = { draw_circle };
DrawingAPI square_api = { draw_square };

Shape create_shape(DrawingAPI* api) {
    Shape shape = { api, api->draw };
    return shape;
}

void test() {
    Shape circle = create_shape(&circle_api);
    Shape square = create_shape(&square_api);

    circle.draw("Circle API");
    square.draw("Square API");

}

// #include <iostream>
// #include <memory>

class DrawingAPI {
public:
    virtual void draw(const std::string& api_name) const = 0;
    virtual ~DrawingAPI() = default;
};

class CircleDrawingAPI : public DrawingAPI {
public:
    void draw(const std::string& api_name) const override {
        std::cout << "Drawing Circle using " << api_name << std::endl;
    }
};

class SquareDrawingAPI : public DrawingAPI {
public:
    void draw(const std::string& api_name) const override {
        std::cout << "Drawing Square using " << api_name << std::endl;
    }
};

class Shape {
protected:
    std::shared_ptr<DrawingAPI> drawingAPI;
public:
    Shape(std::shared_ptr<DrawingAPI> api) : drawingAPI(api) {}
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    Circle(std::shared_ptr<DrawingAPI> api) : Shape(api) {}
    void draw() const override {
        drawingAPI->draw("Circle API");
    }
};

class Square : public Shape {
public:
    Square(std::shared_ptr<DrawingAPI> api) : Shape(api) {}
    void draw() const override {
        drawingAPI->draw("Square API");
    }
};

void test() {
    std::shared_ptr<DrawingAPI> circleAPI = std::make_shared<CircleDrawingAPI>();
    std::shared_ptr<DrawingAPI> squareAPI = std::make_shared<SquareDrawingAPI>();

    Circle circle(circleAPI);
    Square square(squareAPI);

    circle.draw();
    square.draw();

}

// Prototype

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    char* type;
    void (*clone)(const char*);
} Prototype;

void clone_type(const char* type) {
    printf("Cloning %s\n", type);
}

Prototype* create_prototype(const char* type) {
    Prototype* prototype = (Prototype*)malloc(sizeof(Prototype));
    prototype->type = strdup(type);
    prototype->clone = clone_type;
    return prototype;
}

void test() {
    Prototype* prototype1 = create_prototype("Type1");
    Prototype* prototype2 = create_prototype("Type2");

    prototype1->clone(prototype1->type);
    prototype2->clone(prototype2->type);

    free(prototype1->type);
    free(prototype1);
    free(prototype2->type);
    free(prototype2);
}

// #include <iostream>
// #include <memory>
// #include <string>

class Prototype {
protected:
    std::string type;
public:
    Prototype(const std::string& type) : type(type) {}
    virtual std::shared_ptr<Prototype> clone() const = 0;
    virtual void printType() const {
        std::cout << "Type: " << type << std::endl;
    }
    virtual ~Prototype() = default;
};

class ConcretePrototype1 : public Prototype {
public:
    ConcretePrototype1(const std::string& type) : Prototype(type) {}
    std::shared_ptr<Prototype> clone() const override {
        return std::make_shared<ConcretePrototype1>(*this);
    }
};

class ConcretePrototype2 : public Prototype {
public:
    ConcretePrototype2(const std::string& type) : Prototype(type) {}
    std::shared_ptr<Prototype> clone() const override {
        return std::make_shared<ConcretePrototype2>(*this);
    }
};

void test() {
    std::shared_ptr<Prototype> prototype1 = std::make_shared<ConcretePrototype1>("Type1");
    std::shared_ptr<Prototype> prototype2 = std::make_shared<ConcretePrototype2>("Type2");

    std::shared_ptr<Prototype> cloned1 = prototype1->clone();
    std::shared_ptr<Prototype> cloned2 = prototype2->clone();

    cloned1->printType();
    cloned2->printType();

}

// Flyweight

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct {
    char* intrinsicState;
} Flyweight;

typedef struct {
    Flyweight** flyweights;
    int size;
} FlyweightFactory;

Flyweight* create_flyweight(const char* state) {
    Flyweight* flyweight = (Flyweight*)malloc(sizeof(Flyweight));
    flyweight->intrinsicState = strdup(state);
    return flyweight;
}

FlyweightFactory* create_flyweight_factory() {
    FlyweightFactory* factory = (FlyweightFactory*)malloc(sizeof(FlyweightFactory));
    factory->flyweights = (Flyweight**)malloc(sizeof(Flyweight*) * 10);
    factory->size = 0;
    return factory;
}

Flyweight* get_flyweight(FlyweightFactory* factory, const char* state) {
    for (int i = 0; i < factory->size; ++i) {
        if (strcmp(factory->flyweights[i]->intrinsicState, state) == 0) {
            return factory->flyweights[i];
        }
    }
    Flyweight* flyweight = create_flyweight(state);
    factory->flyweights[factory->size++] = flyweight;
    return flyweight;
}

void use_flyweight(Flyweight* flyweight, const char* extrinsicState) {
    printf("Using Flyweight with intrinsic state %s and extrinsic state %s\n", flyweight->intrinsicState, extrinsicState);
}

void test() {
    FlyweightFactory* factory = create_flyweight_factory();

    Flyweight* flyweight1 = get_flyweight(factory, "State1");
    Flyweight* flyweight2 = get_flyweight(factory, "State2");
    Flyweight* flyweight3 = get_flyweight(factory, "State1");

    use_flyweight(flyweight1, "Extrinsic1");
    use_flyweight(flyweight2, "Extrinsic2");
    use_flyweight(flyweight3, "Extrinsic3");

    free(flyweight1->intrinsicState);
    free(flyweight2->intrinsicState);
    free(flyweight1);
    free(flyweight2);
    free(factory->flyweights);
    free(factory);
}

// #include <iostream>
// #include <memory>
// #include <string>
// #include <unordered_map>

class Flyweight {
private:
    std::string intrinsicState;
public:
    Flyweight(const std::string& state) : intrinsicState(state) {}
    void operation(const std::string& extrinsicState) const {
        std::cout << "Using Flyweight with intrinsic state " << intrinsicState << " and extrinsic state " << extrinsicState << std::endl;
    }
};

class FlyweightFactory {
private:
    std::unordered_map<std::string, std::shared_ptr<Flyweight>> flyweights;
public:
    std::shared_ptr<Flyweight> getFlyweight(const std::string& state) {
        auto it = flyweights.find(state);
        if (it != flyweights.end()) {
            return it->second;
        } else {
            auto flyweight = std::make_shared<Flyweight>(state);
            flyweights[state] = flyweight;
            return flyweight;
        }
    }
};

void test() {
    FlyweightFactory factory;

    std::shared_ptr<Flyweight> flyweight1 = factory.getFlyweight("State1");
    std::shared_ptr<Flyweight> flyweight2 = factory.getFlyweight("State2");
    std::shared_ptr<Flyweight> flyweight3 = factory.getFlyweight("State1");

    flyweight1->operation("Extrinsic1");
    flyweight2->operation("Extrinsic2");
    flyweight3->operation("Extrinsic3");

}

// Proxy

// #include <stdio.h>
// #include <stdlib.h>

typedef struct {
    void (*request)();
} Subject;

void real_request() {
    printf("Real request\n");
}

typedef struct {
    Subject subject;
} RealSubject;

typedef struct {
    Subject subject;
    RealSubject* realSubject;
} Proxy;

void proxy_request(Proxy* proxy) {
    if (proxy->realSubject == NULL) {
        proxy->realSubject = (RealSubject*)malloc(sizeof(RealSubject));
        proxy->realSubject->subject.request = real_request;
    }
    proxy->realSubject->subject.request();
}

Proxy* create_proxy() {
    Proxy* proxy = (Proxy*)malloc(sizeof(Proxy));
    proxy->subject.request = (void (*)(void))proxy_request;
    proxy->realSubject = NULL;
    return proxy;
}

void test() {
    Proxy* proxy = create_proxy();
    proxy->subject.request(proxy);
    free(proxy->realSubject);
    free(proxy);
}

// #include <iostream>
// #include <memory>

class Subject {
public:
    virtual void request() const = 0;
    virtual ~Subject() = default;
};

class RealSubject : public Subject {
public:
    void request() const override {
        std::cout << "Real request" << std::endl;
    }
};

class Proxy : public Subject {
private:
    std::unique_ptr<RealSubject> realSubject;
public:
    void request() const override {
        if (!realSubject) {
            realSubject = std::make_unique<RealSubject>();
        }
        realSubject->request();
    }
};

void test() {
    Proxy proxy;
    proxy.request();
}

// Composite

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>

typedef struct Component {
    void (*operation)(struct Component*);
    struct Component* next;
} Component;

void leaf_operation(Component* component) {
    printf("Leaf operation\n");
}

Component* create_leaf() {
    Component* leaf = (Component*)malloc(sizeof(Component));
    leaf->operation = leaf_operation;
    leaf->next = NULL;
    return leaf;
}

void composite_operation(Component* component) {
    printf("Composite operation\n");
    Component* child = component->next;
    while (child != NULL) {
        child->operation(child);
        child = child->next;
    }
}

Component* create_composite() {
    Component* composite = (Component*)malloc(sizeof(Component));
    composite->operation = composite_operation;
    composite->next = NULL;
    return composite;
}

void add_child(Component* parent, Component* child) {
    child->next = parent->next;
    parent->next = child;
}

void test() {
    Component* composite = create_composite();
    Component* leaf1 = create_leaf();
    Component* leaf2 = create_leaf();

    add_child(composite, leaf1);
    add_child(composite, leaf2);

    composite->operation(composite);

    free(leaf1);
    free(leaf2);
    free(composite);
}

// #include <iostream>
// #include <vector>
// #include <memory>

class Component {
public:
    virtual void operation() const = 0;
    virtual ~Component() = default;
};

class Leaf : public Component {
public:
    void operation() const override {
        std::cout << "Leaf operation" << std::endl;
    }
};

class Composite : public Component {
private:
    std::vector<std::shared_ptr<Component>> children;
public:
    void add(const std::shared_ptr<Component>& component) {
        children.push_back(component);
    }
    void operation() const override {
        std::cout << "Composite operation" << std::endl;
        for (const auto& child : children) {
            child->operation();
        }
    }
};

void test() {
    std::shared_ptr<Composite> composite = std::make_shared<Composite>();
    std::shared_ptr<Component> leaf1 = std::make_shared<Leaf>();
    std::shared_ptr<Component> leaf2 = std::make_shared<Leaf>();

    composite->add(leaf1);
    composite->add(leaf2);

    composite->operation();
}
