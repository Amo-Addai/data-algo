


// TODO: Creational Patterns

// Object Pool

// #include <stdio.h>
// #include <stdlib.h>

#define POOL_SIZE 5

typedef struct {
    int id;
    int in_use;
} Object;

Object pool[POOL_SIZE];

void initialize_pool() {
    for (int i = 0; i < POOL_SIZE; i++) {
        pool[i].id = i;
        pool[i].in_use = 0;
    }
}

Object* get_object() {
    for (int i = 0; i < POOL_SIZE; i++) {
        if (!pool[i].in_use) {
            pool[i].in_use = 1;
            return &pool[i];
        }
    }
    return NULL;
}

void release_object(Object* obj) {
    obj->in_use = 0;
}

void test() {
    initialize_pool();
    Object* obj1 = get_object();
    if (obj1) {
        printf("Got object with ID: %d\n", obj1->id);
    }
    release_object(obj1);
}

// #include <iostream>
// #include <vector>
// #include <memory>

class Object {
    int id;
    bool in_use;
public:
    Object(int id) : id(id), in_use(false) {}
    int getId() const { return id; }
    bool isInUse() const { return in_use; }
    void setInUse(bool inUse) { in_use = inUse; }
};

class ObjectPool {
    std::vector<std::shared_ptr<Object>> pool;
public:
    ObjectPool(int size) {
        for (int i = 0; i < size; ++i) {
            pool.push_back(std::make_shared<Object>(i));
        }
    }

    std::shared_ptr<Object> getObject() {
        for (auto& obj : pool) {
            if (!obj->isInUse()) {
                obj->setInUse(true);
                return obj;
            }
        }
        return nullptr;
    }

    void releaseObject(const std::shared_ptr<Object>& obj) {
        obj->setInUse(false);
    }
};

void test() {
    ObjectPool pool(5);
    auto obj1 = pool.getObject();
    if (obj1) {
        std::cout << "Got object with ID: " << obj1->getId() << std::endl;
    }
    pool.releaseObject(obj1);
}



// TODO: Structural Patterns

// Bridge

// #include <stdio.h>

typedef struct Implementor Implementor;

struct Implementor {
    void (*operation)();
};

typedef struct {
    Implementor* implementor;
    void (*operation)();
} Abstraction;

void operationA() {
    printf("Operation A\n");
}

void operationB() {
    printf("Operation B\n");
}

void abstraction_operation(Abstraction* abstraction) {
    abstraction->implementor->operation();
}

void test() {
    Implementor implA = { operationA };
    Implementor implB = { operationB };

    Abstraction absA = { &implA, abstraction_operation };
    Abstraction absB = { &implB, abstraction_operation };

    absA.operation(&absA);
    absB.operation(&absB);

}

// #include <iostream>
// #include <memory>

class Implementor {
public:
    virtual void operation() const = 0;
    virtual ~Implementor() = default;
};

class ConcreteImplementorA : public Implementor {
public:
    void operation() const override {
        std::cout << "Operation A" << std::endl;
    }
};

class ConcreteImplementorB : public Implementor {
public:
    void operation() const override {
        std::cout << "Operation B" << std::endl;
    }
};

class Abstraction {
protected:
    std::shared_ptr<Implementor> implementor;
public:
    Abstraction(std::shared_ptr<Implementor> impl) : implementor(impl) {}
    virtual void operation() const {
        implementor->operation();
    }
    virtual ~Abstraction() = default;
};

void test() {
    auto implA = std::make_shared<ConcreteImplementorA>();
    auto implB = std::make_shared<ConcreteImplementorB>();

    Abstraction absA(implA);
    Abstraction absB(implB);

    absA.operation();
    absB.operation();

}

// Facade

// #include <stdio.h>

void subsystem1_operation() {
    printf("Subsystem 1 operation\n");
}

void subsystem2_operation() {
    printf("Subsystem 2 operation\n");
}

void subsystem3_operation() {
    printf("Subsystem 3 operation\n");
}

void facade_operation() {
    subsystem1_operation();
    subsystem2_operation();
    subsystem3_operation();
}

void test() {
    facade_operation();
}

// #include <iostream>

class Subsystem1 {
public:
    void operation() const {
        std::cout << "Subsystem 1 operation" << std::endl;
    }
};

class Subsystem2 {
public:
    void operation() const {
        std::cout << "Subsystem 2 operation" << std::endl;
    }
};

class Subsystem3 {
public:
    void operation() const {
        std::cout << "Subsystem 3 operation" << std::endl;
    }
};

class Facade {
    Subsystem1 subsystem1;
    Subsystem2 subsystem2;
    Subsystem3 subsystem3;
public:
    void operation() const {
        subsystem1.operation();
        subsystem2.operation();
        subsystem3.operation();
    }
};

void test() {
    Facade facade;
    facade.operation();
}



// TODO: Behavioral Patterns

// Template Method

// #include <stdio.h>

void step1() {
    printf("Step 1\n");
}

void step2() {
    printf("Step 2\n");
}

void step3() {
    printf("Step 3\n");
}

void template_method() {
    step1();
    step2();
    step3();
}

void test() {
    template_method();
}

// #include <iostream>

class AbstractClass {
public:
    void templateMethod() const {
        step1();
        step2();
        step3();
    }
protected:
    virtual void step1() const {
        std::cout << "Step 1" << std::endl;
    }
    virtual void step2() const {
        std::cout << "Step 2" << std::endl;
    }
    virtual void step3() const {
        std::cout << "Step 3" << std::endl;
    }
};

class ConcreteClass : public AbstractClass {
protected:
    void step1() const override {
        std::cout << "Concrete Step 1" << std::endl;
    }
};

void test() {
    ConcreteClass obj;
    obj.templateMethod();
}



// TODO: Concurrency Patterns

// Thread Pool

// #include <stdio.h>
// #include <stdlib.h>
// #include <pthread.h>

#define NUM_THREADS 5

void* worker(void* arg) {
    printf("Thread %d is working\n", *(int*)arg);
    return NULL;
}

void test() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; ++i) {
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, worker, &thread_ids[i]);
    }

    for (int i = 0; i < NUM_THREADS; ++i) {
        pthread_join(threads[i], NULL);
    }

}

// #include <iostream>
// #include <thread>
// #include <vector>

void worker(int id) {
    std::cout << "Thread " << id << " is working" << std::endl;
}

void test() {
    const int num_threads = 5;
    std::vector<std::thread> threads;

    for (int i = 0; i < num_threads; ++i) {
        threads.push_back(std::thread(worker, i));
    }

    for (auto& thread : threads) {
        thread.join();
    }

}

// Producer-Consumer

// #include <stdio.h>
// #include <stdlib.h>
// #include <pthread.h>
// #include <semaphore.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int count = 0;

pthread_mutex_t mutex;
sem_t empty, full;

void* producer(void* arg) {
    int item;
    while (1) {
        item = rand() % 100;
        sem_wait(&empty);
        pthread_mutex_lock(&mutex);
        buffer[count++] = item;
        printf("Produced %d\n", item);
        pthread_mutex_unlock(&mutex);
        sem_post(&full);
    }
    return NULL;
}

void* consumer(void* arg) {
    int item;
    while (1) {
        sem_wait(&full);
        pthread_mutex_lock(&mutex);
        item = buffer[--count];
        printf("Consumed %d\n", item);
        pthread_mutex_unlock(&mutex);
        sem_post(&empty);
    }
    return NULL;
}

void test() {
    pthread_t prod, cons;

    pthread_mutex_init(&mutex, NULL);
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);

    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&mutex);
    sem_destroy(&empty);
    sem_destroy(&full);

}

// #include <iostream>
// #include <queue>
// #include <thread>
// #include <mutex>
// #include <condition_variable>

std::queue<int> buffer;
const unsigned int buffer_size = 5;
std::mutex mtx;
std::condition_variable cv_empty, cv_full;

void producer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv_empty.wait(lock, [] { return buffer.size() < buffer_size; });
        int item = rand() % 100;
        buffer.push(item);
        std::cout << "Produced " << item << std::endl;
        cv_full.notify_one();
    }
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv_full.wait(lock, [] { return !buffer.empty(); });
        int item = buffer.front();
        buffer.pop();
        std::cout << "Consumed " << item << std::endl;
        cv_empty.notify_one();
    }
}

void test() {
    std::thread prod(producer);
    std::thread cons(consumer);

    prod.join();
    cons.join();

}

// Read-Write Lock

// #include <stdio.h>
// #include <pthread.h>

pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void* reader(void* arg) {
    pthread_rwlock_rdlock(&rwlock);
    printf("Reader %ld is reading\n", (long)arg);
    pthread_rwlock_unlock(&rwlock);
    return NULL;
}

void* writer(void* arg) {
    pthread_rwlock_wrlock(&rwlock);
    printf("Writer %ld is writing\n", (long)arg);
    pthread_rwlock_unlock(&rwlock);
    return NULL;
}

void test() {
    pthread_t threads[3];

    pthread_create(&threads[0], NULL, reader, (void*)1);
    pthread_create(&threads[1], NULL, writer, (void*)2);
    pthread_create(&threads[2], NULL, reader, (void*)3);

    for (int i = 0; i < 3; ++i) {
        pthread_join(threads[i], NULL);
    }

    pthread_rwlock_destroy(&rwlock);
}

// #include <iostream>
// #include <shared_mutex>
// #include <thread>

std::shared_mutex rwlock;

void reader(int id) {
    std::shared_lock<std::shared_mutex> lock(rwlock);
    std::cout << "Reader " << id << " is reading" << std::endl;
}

void writer(int id) {
    std::unique_lock<std::shared_mutex> lock(rwlock);
    std::cout << "Writer " << id << " is writing" << std::endl;
}

void test() {
    std::thread t1(reader, 1);
    std::thread t2(writer, 2);
    std::thread t3(reader, 3);

    t1.join();
    t2.join();
    t3.join();

}

// Barrier

// #include <stdio.h>
// #include <pthread.h>

#define NUM_THREADS 3

pthread_barrier_t barrier;

void* worker(void* arg) {
    printf("Thread %d before barrier\n", *(int*)arg);
    pthread_barrier_wait(&barrier);
    printf("Thread %d after barrier\n", *(int*)arg);
    return NULL;
}

void test() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];

    pthread_barrier_init(&barrier, NULL, NUM_THREADS);

    for (int i = 0; i < NUM_THREADS; ++i) {
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, worker, &thread_ids[i]);
    }

    for (int i = 0; i < NUM_THREADS; ++i) {
        pthread_join(threads[i], NULL);
    }

    pthread_barrier_destroy(&barrier);
}

// #include <iostream>
// #include <thread>
// #include <barrier>

void worker(int id, std::barrier<>& bar) {
    std::cout << "Thread " << id << " before barrier" << std::endl;
    bar.arrive_and_wait();
    std::cout << "Thread " << id << " after barrier" << std::endl;
}

void test() {
    const int num_threads = 3;
    std::barrier bar(num_threads);
    std::vector<std::thread> threads;

    for (int i = 0; i < num_threads; ++i) {
        threads.push_back(std::thread(worker, i, std::ref(bar)));
    }

    for (auto& thread : threads) {
        thread.join();
    }

}

// Monitor Object

// #include <stdio.h>
// #include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

void* thread_func(void* arg) {
    pthread_mutex_lock(&mutex);
    printf("Thread %ld waiting\n", (long)arg);
    pthread_cond_wait(&cond, &mutex);
    printf("Thread %ld proceeding\n", (long)arg);
    pthread_mutex_unlock(&mutex);
    return NULL;
}

void test() {
    pthread_t threads[2];

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    pthread_create(&threads[0], NULL, thread_func, (void*)1);
    pthread_create(&threads[1], NULL, thread_func, (void*)2);

    sleep(1);
    pthread_mutex_lock(&mutex);
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&mutex);

    for (int i = 0; i < 2; ++i) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

}

// #include <iostream>
// #include <thread>
// #include <mutex>
// #include <condition_variable>

std::mutex mtx;
std::condition_variable cv;

void thread_func(int id) {
    std::unique_lock<std::mutex> lock(mtx);
    std::cout << "Thread " << id << " waiting" << std::endl;
    cv.wait(lock);
    std::cout << "Thread " << id << " proceeding" << std::endl;
}

void test() {
    std::thread t1(thread_func, 1);
    std::thread t2(thread_func, 2);

    std::this_thread::sleep_for(std::chrono::seconds(1));
    cv.notify_one();

    t1.join();
    t2.join();

}



// TODO: Functional Patterns

// Map-Reduce

// #include <stdio.h>

int map(int x) {
    return x * x;
}

int reduce(int x, int y) {
    return x + y;
}

void test() {
    int arr[] = {1, 2, 3, 4, 5};
    int mapped[5];
    int reduced = 0;

    for (int i = 0; i < 5; ++i) {
        mapped[i] = map(arr[i]);
    }

    for (int i = 0; i < 5; ++i) {
        reduced = reduce(reduced, mapped[i]);
    }

    printf("Reduced value: %d\n", reduced);
}

// #include <iostream>
// #include <vector>
// #include <numeric>

int map(int x) {
    return x * x;
}

int reduce(int x, int y) {
    return x + y;
}

void test() {
    std::vector<int> arr = {1, 2, 3, 4, 5};
    std::vector<int> mapped;

    std::transform(arr.begin(), arr.end(), std::back_inserter(mapped), map);
    int reduced = std::accumulate(mapped.begin(), mapped.end(), 0, reduce);

    std::cout << "Reduced value: " << reduced << std::endl;
}

// Functor

// #include <stdio.h>

typedef struct {
    int (*operator)(int);
} Functor;

int increment(int x) {
    return x + 1;
}

void test() {
    Functor f = { increment };
    int value = 5;
    printf("Incremented value: %d\n", f.operator(value));
}

// #include <iostream>

class Functor {
public:
    int operator()(int x) const {
        return x + 1;
    }
};

void test() {
    Functor f;
    int value = 5;
    std::cout << "Incremented value: " << f(value) << std::endl;
}

// Monad

// #include <stdio.h>

typedef struct {
    int value;
} Maybe;

Maybe just(int x) {
    Maybe m = { x };
    return m;
}

Maybe bind(Maybe m, Maybe(*func)(int)) {
    return func(m.value);
}

Maybe increment(int x) {
    return just(x + 1);
}

void test() {
    Maybe m = just(5);
    m = bind(m, increment);
    printf("Value: %d\n", m.value);
}

// #include <iostream>
// #include <functional>

template <typename T>
class Maybe {
    T value;
public:
    Maybe(T v) : value(v) {}
    template <typename F>
    auto bind(F func) -> Maybe<decltype(func(value).value)> {
        return func(value);
    }
    T getValue() const {
        return value;
    }
};

Maybe<int> just(int x) {
    return Maybe<int>(x);
}

Maybe<int> increment(int x) {
    return just(x + 1);
}

void test() {
    auto m = just(5).bind(increment);
    std::cout << "Value: " << m.getValue() << std::endl;
}

// Currying

// #include <stdio.h>

int add(int x, int y) {
    return x + y;
}

typedef struct {
    int (*func)(int);
} CurriedAdd;

CurriedAdd curry(int (*func)(int, int), int x) {
    CurriedAdd ca = { [func, x](int y) { return func(x, y); } };
    return ca;
}

void test() {
    CurriedAdd add5 = curry(add, 5);
    printf("Result: %d\n", add5.func(10));
}

// #include <iostream>
// #include <functional>

auto add = [](int x, int y) {
    return x + y;
};

auto curry(std::function<int(int, int)> func, int x) {
    return [func, x](int y) {
        return func(x, y);
    };
}

void test() {
    auto add5 = curry(add, 5);
    std::cout << "Result: " << add5(10) << std::endl;
}

// Pure Function

// #include <stdio.h>

int add(int x, int y) {
    return x + y;
}

void test() {
    int result = add(3, 4);
    printf("Result: %d\n", result);
}

// #include <iostream>

int add(int x, int y) {
    return x + y;
}

void test() {
    int result = add(3, 4);
    std::cout << "Result: " << result << std::endl;
}
